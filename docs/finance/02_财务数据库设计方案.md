# 财务数据库设计方案

> **文档版本:** v1.0
> **更新日期:** 2025-11-15
> **数据库类型:** PostgreSQL 15
> **ORM框架:** SQLAlchemy 2.0
> **文档状态:** ✅ 设计完成

---

## 1. 架构设计决策

### 1.1 设计目标

| 目标 | 说明 | 优先级 |
|------|------|--------|
| **数据隔离** | 与业务库（medpol）完全隔离 | P0 |
| **高性能** | 查询响应时间 < 100ms | P0 |
| **易维护** | 独立备份、独立扩展 | P1 |
| **数据完整性** | 防止重复数据、保证一致性 | P0 |
| **可扩展性** | 支持未来数据量增长 | P1 |

### 1.2 独立数据库 vs 同库不同Schema

| 方案 | 优点 | 缺点 | 选择 |
|------|------|------|------|
| **独立PostgreSQL实例** | ✅ 完全隔离<br>✅ 独立资源配置<br>✅ 独立备份恢复<br>✅ 无业务库风险传播 | ❌ 需要额外端口<br>❌ 多一个数据库连接 | ✅ **采用** |
| **同实例不同Schema** | ✅ 节省资源<br>✅ 单一连接配置 | ❌ 共享资源池<br>❌ 业务库故障可能影响财务库 | ❌ 不采用 |

**最终决策：** 使用**独立PostgreSQL实例**（medpol_finance）

**决策理由：**
1. 财务数据敏感性高，需要完全隔离
2. AI查询频繁，避免与业务库争抢连接池
3. 独立扩展，未来可迁移到独立服务器
4. 资源成本可接受（仅1GB左右数据）

### 1.3 数据库实例规划

```
业务库实例：
- 数据库名称：medpol
- 端口：5432
- 用户：medpol
- 数据规模：~10GB
- 用途：文章、爬虫、AI结果等业务数据

财务库实例：（新建）
- 数据库名称：medpol_finance
- 端口：5433
- 用户：finance_user
- 数据规模：~100MB（预计3年内<1GB）
- 用途：财务数据存储、AI查询
```

---

## 2. 数据库连接配置

### 2.1 环境变量配置

#### `.env` 文件新增配置

```ini
# ========== 财务数据库配置 ==========
FINANCE_DATABASE_URL=postgresql+psycopg://finance_user:SecurePass123@localhost:5433/medpol_finance
FINANCE_DB_POOL_SIZE=10
FINANCE_DB_MAX_OVERFLOW=20
FINANCE_DB_POOL_TIMEOUT=30
FINANCE_DB_ECHO=false
```

#### `.env.example` 更新

```ini
# ========== 财务数据库配置 ==========
# 独立财务数据库实例（用于财务数据存储和AI查询）
FINANCE_DATABASE_URL=postgresql+psycopg://finance_user:finance_password@localhost:5433/medpol_finance

# 连接池配置
FINANCE_DB_POOL_SIZE=10          # 连接池大小
FINANCE_DB_MAX_OVERFLOW=20       # 最大溢出连接数
FINANCE_DB_POOL_TIMEOUT=30       # 连接超时（秒）
FINANCE_DB_ECHO=false            # 是否打印SQL日志
```

### 2.2 Settings 配置类更新

**文件：** `common/utils/config.py`

```python
from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    # ========== 业务数据库配置 ==========
    database_url: str = Field(..., env="DATABASE_URL")

    # ========== 财务数据库配置 ========== (新增)
    finance_database_url: str = Field(..., env="FINANCE_DATABASE_URL")
    finance_db_pool_size: int = Field(10, env="FINANCE_DB_POOL_SIZE")
    finance_db_max_overflow: int = Field(20, env="FINANCE_DB_MAX_OVERFLOW")
    finance_db_pool_timeout: int = Field(30, env="FINANCE_DB_POOL_TIMEOUT")
    finance_db_echo: bool = Field(False, env="FINANCE_DB_ECHO")

    # ... 其他配置
    model_config = SettingsConfigDict(
        case_sensitive=False,
        env_file=".env",
        env_file_encoding="utf-8",
        extra="allow",
    )
```

### 2.3 Docker Compose 配置

**文件：** `infra/docker-compose.yml`

新增财务数据库服务：

```yaml
services:
  # 业务数据库（保留）
  postgres:
    image: postgres:15-alpine
    container_name: medpol-postgres
    environment:
      POSTGRES_USER: medpol
      POSTGRES_PASSWORD: medpol
      POSTGRES_DB: medpol
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - medpol-net

  # 财务数据库（新增）
  postgres-finance:
    image: postgres:15-alpine
    container_name: medpol-postgres-finance
    environment:
      POSTGRES_USER: finance_user
      POSTGRES_PASSWORD: finance_password
      POSTGRES_DB: medpol_finance
    ports:
      - "5433:5432"
    volumes:
      - postgres-finance-data:/var/lib/postgresql/data
    networks:
      - medpol-net
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U finance_user -d medpol_finance"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres-data:
  postgres-finance-data:  # 新增

networks:
  medpol-net:
    driver: bridge
```

---

## 3. 表结构设计

### 3.1 finance_data 表（财务数据主表）

#### 3.1.1 表结构定义

```sql
CREATE TABLE finance_data (
    -- 主键
    id VARCHAR(36) PRIMARY KEY,

    -- 公司信息
    company_no VARCHAR(32) NOT NULL,
    company_id INTEGER NOT NULL,
    company_name VARCHAR(128) NOT NULL,
    company_level VARCHAR(4) NOT NULL,

    -- 财务类型
    type_no VARCHAR(8) NOT NULL,

    -- 记账日期
    keep_date DATE NOT NULL,

    -- 财务金额字段（单位：万元，保留2位小数）
    current_amt NUMERIC(18, 2),
    last_year_amt NUMERIC(18, 2),
    last_year_total_amt NUMERIC(18, 2),
    this_year_total_amt NUMERIC(18, 2),

    -- 增长指标（保留4位小数）
    add_amt NUMERIC(18, 2),
    add_rate NUMERIC(10, 4),
    year_add_amt NUMERIC(18, 2),
    year_add_rate NUMERIC(10, 4),

    -- 元数据
    remarks TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    synced_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    -- 唯一约束（防止重复数据）
    CONSTRAINT uk_finance_data UNIQUE (company_no, type_no, keep_date)
);

-- 索引优化
CREATE INDEX idx_finance_data_company ON finance_data(company_no);
CREATE INDEX idx_finance_data_type ON finance_data(type_no);
CREATE INDEX idx_finance_data_date ON finance_data(keep_date);
CREATE INDEX idx_finance_data_company_type ON finance_data(company_no, type_no);
CREATE INDEX idx_finance_data_date_range ON finance_data(keep_date DESC);

-- 复合索引（优化AI查询）
CREATE INDEX idx_finance_data_query ON finance_data(company_no, type_no, keep_date);

-- 注释
COMMENT ON TABLE finance_data IS '财务数据主表';
COMMENT ON COLUMN finance_data.id IS '记录唯一标识';
COMMENT ON COLUMN finance_data.company_no IS '公司编号';
COMMENT ON COLUMN finance_data.type_no IS '财务类型编号（01-08）';
COMMENT ON COLUMN finance_data.keep_date IS '记账日期';
COMMENT ON COLUMN finance_data.current_amt IS '当期金额（万元）';
COMMENT ON COLUMN finance_data.add_rate IS '月环比增长率（%）';
COMMENT ON COLUMN finance_data.year_add_rate IS '年同比增长率（%）';
```

#### 3.1.2 字段说明

| 字段名 | 类型 | 约束 | 说明 | 索引 |
|--------|------|------|------|------|
| `id` | VARCHAR(36) | PRIMARY KEY | UUID格式的唯一标识 | ✅ 主键 |
| `company_no` | VARCHAR(32) | NOT NULL | 公司编号（如 lhjt） | ✅ 索引 |
| `company_id` | INTEGER | NOT NULL | 公司ID | - |
| `company_name` | VARCHAR(128) | NOT NULL | 公司名称（如 集团(合)） | - |
| `company_level` | VARCHAR(4) | NOT NULL | 公司层级（0=一级，1=二级） | - |
| `type_no` | VARCHAR(8) | NOT NULL | 财务类型编号（01-08） | ✅ 索引 |
| `keep_date` | DATE | NOT NULL | 记账日期 | ✅ 索引 |
| `current_amt` | NUMERIC(18,2) | | 当期金额（万元） | - |
| `last_year_amt` | NUMERIC(18,2) | | 去年同期金额 | - |
| `last_year_total_amt` | NUMERIC(18,2) | | 去年累计金额 | - |
| `this_year_total_amt` | NUMERIC(18,2) | | 今年累计金额 | - |
| `add_amt` | NUMERIC(18,2) | | 月环比增减额 | - |
| `add_rate` | NUMERIC(10,4) | | 月环比增长率（%） | - |
| `year_add_amt` | NUMERIC(18,2) | | 年同比增减额 | - |
| `year_add_rate` | NUMERIC(10,4) | | 年同比增长率（%） | - |
| `remarks` | TEXT | | 备注信息 | - |
| `created_at` | TIMESTAMP | DEFAULT NOW() | 记录创建时间 | - |
| `synced_at` | TIMESTAMP | DEFAULT NOW() | 数据同步时间 | - |

**唯一约束：** `(company_no, type_no, keep_date)` - 防止同一公司、同一类型、同一月份的重复数据

#### 3.1.3 数据示例

```sql
INSERT INTO finance_data VALUES (
    '1',                        -- id
    'lhjt',                     -- company_no
    1,                          -- company_id
    '集团(合)',                  -- company_name
    '0',                        -- company_level
    '01',                       -- type_no
    '2024-01-01',               -- keep_date
    66455.17,                   -- current_amt
    46842.14,                   -- last_year_amt
    46842.14,                   -- last_year_total_amt
    66455.17,                   -- this_year_total_amt
    19613.03,                   -- add_amt
    41.8700,                    -- add_rate
    19613.03,                   -- year_add_amt
    41.8700,                    -- year_add_rate
    NULL,                       -- remarks
    NOW(),                      -- created_at
    NOW()                       -- synced_at
);
```

### 3.2 finance_sync_log 表（同步日志表）

#### 3.2.1 表结构定义

```sql
CREATE TABLE finance_sync_log (
    -- 主键
    id VARCHAR(36) PRIMARY KEY,

    -- 同步信息
    sync_month DATE NOT NULL,
    sync_mode VARCHAR(16) NOT NULL,  -- 'full' 或 'incremental'
    status VARCHAR(16) NOT NULL,     -- 'running', 'success', 'failed'

    -- 统计信息
    total_records INTEGER DEFAULT 0,
    new_records INTEGER DEFAULT 0,
    updated_records INTEGER DEFAULT 0,
    duplicate_records INTEGER DEFAULT 0,

    -- 错误信息
    error_message TEXT,

    -- 时间戳
    started_at TIMESTAMP WITH TIME ZONE NOT NULL,
    finished_at TIMESTAMP WITH TIME ZONE,
    duration_ms INTEGER,

    -- 元数据
    api_response_time_ms INTEGER,
    triggered_by VARCHAR(32)  -- 'scheduler', 'manual', 'api'
);

-- 索引
CREATE INDEX idx_sync_log_month ON finance_sync_log(sync_month DESC);
CREATE INDEX idx_sync_log_status ON finance_sync_log(status);
CREATE INDEX idx_sync_log_started ON finance_sync_log(started_at DESC);

-- 注释
COMMENT ON TABLE finance_sync_log IS '财务数据同步日志表';
COMMENT ON COLUMN finance_sync_log.sync_month IS '同步的目标月份';
COMMENT ON COLUMN finance_sync_log.sync_mode IS '同步模式：full=全量，incremental=增量';
COMMENT ON COLUMN finance_sync_log.status IS '同步状态：running, success, failed';
```

#### 3.2.2 字段说明

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `id` | VARCHAR(36) | UUID格式的唯一标识 |
| `sync_month` | DATE | 同步的目标月份（如 2024-03-01） |
| `sync_mode` | VARCHAR(16) | 同步模式（full/incremental） |
| `status` | VARCHAR(16) | 同步状态（running/success/failed） |
| `total_records` | INTEGER | API返回的总记录数 |
| `new_records` | INTEGER | 新增记录数 |
| `updated_records` | INTEGER | 更新记录数（如果支持） |
| `duplicate_records` | INTEGER | 跳过的重复记录数 |
| `error_message` | TEXT | 错误信息（失败时） |
| `started_at` | TIMESTAMP | 同步开始时间 |
| `finished_at` | TIMESTAMP | 同步结束时间 |
| `duration_ms` | INTEGER | 同步耗时（毫秒） |
| `api_response_time_ms` | INTEGER | API响应时间（毫秒） |
| `triggered_by` | VARCHAR(32) | 触发方式（scheduler/manual/api） |

#### 3.2.3 数据示例

```sql
INSERT INTO finance_sync_log VALUES (
    'log-uuid-001',              -- id
    '2024-03-01',                -- sync_month
    'incremental',               -- sync_mode
    'success',                   -- status
    26,                          -- total_records
    26,                          -- new_records
    0,                           -- updated_records
    0,                           -- duplicate_records
    NULL,                        -- error_message
    '2024-04-01 04:00:00+00',    -- started_at
    '2024-04-01 04:00:15+00',    -- finished_at
    15000,                       -- duration_ms (15秒)
    1200,                        -- api_response_time_ms (1.2秒)
    'scheduler'                  -- triggered_by
);
```

---

## 4. SQLAlchemy ORM 模型

### 4.1 Base 和 Session 配置

**文件：** `common/persistence/finance_database.py`

```python
from contextlib import contextmanager
from typing import Generator
from sqlalchemy import create_engine
from sqlalchemy.orm import DeclarativeBase, Session, sessionmaker
from common.utils.config import get_settings

class FinanceBase(DeclarativeBase):
    """财务数据库ORM基类"""
    pass

_finance_engine = None
_finance_session_factory = None

def get_finance_engine():
    """获取财务数据库引擎（单例）"""
    global _finance_engine
    if _finance_engine is None:
        settings = get_settings()
        _finance_engine = create_engine(
            settings.finance_database_url,
            pool_size=settings.finance_db_pool_size,
            max_overflow=settings.finance_db_max_overflow,
            pool_timeout=settings.finance_db_pool_timeout,
            echo=settings.finance_db_echo,
            future=True,
        )
    return _finance_engine

def get_finance_session_factory():
    """获取财务数据库Session工厂（单例）"""
    global _finance_session_factory
    if _finance_session_factory is None:
        engine = get_finance_engine()
        _finance_session_factory = sessionmaker(
            bind=engine,
            class_=Session,
            expire_on_commit=False,
            future=True,
        )
    return _finance_session_factory

@contextmanager
def finance_session_scope() -> Generator[Session, None, None]:
    """财务数据库Session上下文管理器

    Usage:
        with finance_session_scope() as session:
            repo = FinanceDataRepository(session)
            data = repo.list_all()
    """
    factory = get_finance_session_factory()
    session = factory()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()
```

### 4.2 FinanceDataORM 模型

**文件：** `finance_sync_service/models.py`

```python
from datetime import datetime, date
from decimal import Decimal
from typing import Optional
from sqlalchemy import String, Integer, Date, Numeric, Text, DateTime, Index
from sqlalchemy.orm import Mapped, mapped_column
from common.persistence.finance_database import FinanceBase

class FinanceDataORM(FinanceBase):
    """财务数据ORM模型"""

    __tablename__ = "finance_data"

    # 主键
    id: Mapped[str] = mapped_column(String(36), primary_key=True)

    # 公司信息
    company_no: Mapped[str] = mapped_column(String(32), nullable=False, index=True)
    company_id: Mapped[int] = mapped_column(Integer, nullable=False)
    company_name: Mapped[str] = mapped_column(String(128), nullable=False)
    company_level: Mapped[str] = mapped_column(String(4), nullable=False)

    # 财务类型
    type_no: Mapped[str] = mapped_column(String(8), nullable=False, index=True)

    # 记账日期
    keep_date: Mapped[date] = mapped_column(Date, nullable=False, index=True)

    # 财务金额字段（Decimal类型保证精度）
    current_amt: Mapped[Optional[Decimal]] = mapped_column(Numeric(18, 2), nullable=True)
    last_year_amt: Mapped[Optional[Decimal]] = mapped_column(Numeric(18, 2), nullable=True)
    last_year_total_amt: Mapped[Optional[Decimal]] = mapped_column(Numeric(18, 2), nullable=True)
    this_year_total_amt: Mapped[Optional[Decimal]] = mapped_column(Numeric(18, 2), nullable=True)

    # 增长指标
    add_amt: Mapped[Optional[Decimal]] = mapped_column(Numeric(18, 2), nullable=True)
    add_rate: Mapped[Optional[Decimal]] = mapped_column(Numeric(10, 4), nullable=True)
    year_add_amt: Mapped[Optional[Decimal]] = mapped_column(Numeric(18, 2), nullable=True)
    year_add_rate: Mapped[Optional[Decimal]] = mapped_column(Numeric(10, 4), nullable=True)

    # 元数据
    remarks: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=datetime.utcnow
    )
    synced_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=datetime.utcnow
    )

    # 唯一约束
    __table_args__ = (
        Index("uk_finance_data", "company_no", "type_no", "keep_date", unique=True),
        Index("idx_finance_data_query", "company_no", "type_no", "keep_date"),
    )

    def __repr__(self) -> str:
        return (
            f"<FinanceData(id={self.id}, company={self.company_name}, "
            f"type={self.type_no}, date={self.keep_date}, amt={self.current_amt})>"
        )

class FinanceSyncLogORM(FinanceBase):
    """财务数据同步日志ORM模型"""

    __tablename__ = "finance_sync_log"

    # 主键
    id: Mapped[str] = mapped_column(String(36), primary_key=True)

    # 同步信息
    sync_month: Mapped[date] = mapped_column(Date, nullable=False, index=True)
    sync_mode: Mapped[str] = mapped_column(String(16), nullable=False)  # full/incremental
    status: Mapped[str] = mapped_column(String(16), nullable=False, index=True)  # running/success/failed

    # 统计信息
    total_records: Mapped[int] = mapped_column(Integer, default=0)
    new_records: Mapped[int] = mapped_column(Integer, default=0)
    updated_records: Mapped[int] = mapped_column(Integer, default=0)
    duplicate_records: Mapped[int] = mapped_column(Integer, default=0)

    # 错误信息
    error_message: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # 时间戳
    started_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)
    finished_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    duration_ms: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)

    # 元数据
    api_response_time_ms: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    triggered_by: Mapped[Optional[str]] = mapped_column(String(32), nullable=True)

    def __repr__(self) -> str:
        return (
            f"<FinanceSyncLog(id={self.id}, month={self.sync_month}, "
            f"status={self.status}, records={self.new_records})>"
        )
```

---

## 5. Alembic 迁移方案

### 5.1 独立迁移目录

**目录结构：**

```
medpol-platform/
├── migrations/                  # 业务库迁移（保留）
│   ├── env.py
│   └── versions/
│       ├── 0001_init_schema.py
│       └── ...
│
├── migrations_finance/          # 财务库迁移（新建）
│   ├── env.py
│   ├── script.py.mako
│   └── versions/
│       └── 0001_init_finance_schema.py
│
└── alembic_finance.ini          # 财务库Alembic配置（新建）
```

### 5.2 配置文件

**文件：** `alembic_finance.ini`

```ini
[alembic]
script_location = migrations_finance
prepend_sys_path = .
version_path_separator = os

[alembic:exclude]
tables = spatial_ref_sys

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
```

**文件：** `migrations_finance/env.py`

```python
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context
from common.utils.config import get_settings
from common.persistence.finance_database import FinanceBase

# 导入所有ORM模型（确保被Alembic发现）
from finance_sync_service.models import FinanceDataORM, FinanceSyncLogORM

config = context.config
fileConfig(config.config_file_name)

# 设置target_metadata
target_metadata = FinanceBase.metadata

def get_url():
    """从环境变量获取数据库URL"""
    settings = get_settings()
    return settings.finance_database_url

def run_migrations_offline() -> None:
    """离线模式运行迁移"""
    url = get_url()
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online() -> None:
    """在线模式运行迁移"""
    configuration = config.get_section(config.config_ini_section)
    configuration["sqlalchemy.url"] = get_url()
    connectable = engine_from_config(
        configuration,
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
```

### 5.3 初始化迁移脚本

**文件：** `migrations_finance/versions/0001_init_finance_schema.py`

```python
"""init finance schema

Revision ID: 0001
Revises:
Create Date: 2025-11-15
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers
revision = '0001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade() -> None:
    # 创建 finance_data 表
    op.create_table(
        'finance_data',
        sa.Column('id', sa.String(length=36), nullable=False),
        sa.Column('company_no', sa.String(length=32), nullable=False),
        sa.Column('company_id', sa.Integer(), nullable=False),
        sa.Column('company_name', sa.String(length=128), nullable=False),
        sa.Column('company_level', sa.String(length=4), nullable=False),
        sa.Column('type_no', sa.String(length=8), nullable=False),
        sa.Column('keep_date', sa.Date(), nullable=False),
        sa.Column('current_amt', sa.Numeric(precision=18, scale=2), nullable=True),
        sa.Column('last_year_amt', sa.Numeric(precision=18, scale=2), nullable=True),
        sa.Column('last_year_total_amt', sa.Numeric(precision=18, scale=2), nullable=True),
        sa.Column('this_year_total_amt', sa.Numeric(precision=18, scale=2), nullable=True),
        sa.Column('add_amt', sa.Numeric(precision=18, scale=2), nullable=True),
        sa.Column('add_rate', sa.Numeric(precision=10, scale=4), nullable=True),
        sa.Column('year_add_amt', sa.Numeric(precision=18, scale=2), nullable=True),
        sa.Column('year_add_rate', sa.Numeric(precision=10, scale=4), nullable=True),
        sa.Column('remarks', sa.Text(), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('synced_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index('idx_finance_data_company', 'finance_data', ['company_no'])
    op.create_index('idx_finance_data_type', 'finance_data', ['type_no'])
    op.create_index('idx_finance_data_date', 'finance_data', ['keep_date'])
    op.create_index('idx_finance_data_query', 'finance_data', ['company_no', 'type_no', 'keep_date'])
    op.create_index('uk_finance_data', 'finance_data', ['company_no', 'type_no', 'keep_date'], unique=True)

    # 创建 finance_sync_log 表
    op.create_table(
        'finance_sync_log',
        sa.Column('id', sa.String(length=36), nullable=False),
        sa.Column('sync_month', sa.Date(), nullable=False),
        sa.Column('sync_mode', sa.String(length=16), nullable=False),
        sa.Column('status', sa.String(length=16), nullable=False),
        sa.Column('total_records', sa.Integer(), server_default='0', nullable=False),
        sa.Column('new_records', sa.Integer(), server_default='0', nullable=False),
        sa.Column('updated_records', sa.Integer(), server_default='0', nullable=False),
        sa.Column('duplicate_records', sa.Integer(), server_default='0', nullable=False),
        sa.Column('error_message', sa.Text(), nullable=True),
        sa.Column('started_at', sa.DateTime(timezone=True), nullable=False),
        sa.Column('finished_at', sa.DateTime(timezone=True), nullable=True),
        sa.Column('duration_ms', sa.Integer(), nullable=True),
        sa.Column('api_response_time_ms', sa.Integer(), nullable=True),
        sa.Column('triggered_by', sa.String(length=32), nullable=True),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index('idx_sync_log_month', 'finance_sync_log', ['sync_month'], postgresql_ops={'sync_month': 'DESC'})
    op.create_index('idx_sync_log_status', 'finance_sync_log', ['status'])
    op.create_index('idx_sync_log_started', 'finance_sync_log', ['started_at'], postgresql_ops={'started_at': 'DESC'})

    # 添加表注释（PostgreSQL）
    op.execute("COMMENT ON TABLE finance_data IS '财务数据主表'")
    op.execute("COMMENT ON TABLE finance_sync_log IS '财务数据同步日志表'")

def downgrade() -> None:
    op.drop_table('finance_sync_log')
    op.drop_table('finance_data')
```

### 5.4 迁移命令

```powershell
# 初始化Alembic（仅首次）
alembic -c alembic_finance.ini init migrations_finance

# 生成迁移脚本（自动检测模型变更）
alembic -c alembic_finance.ini revision --autogenerate -m "description"

# 执行迁移（升级到最新版本）
alembic -c alembic_finance.ini upgrade head

# 查看当前版本
alembic -c alembic_finance.ini current

# 查看迁移历史
alembic -c alembic_finance.ini history

# 回滚到指定版本
alembic -c alembic_finance.ini downgrade 0001

# 完全回滚
alembic -c alembic_finance.ini downgrade base
```

---

## 6. 性能优化

### 6.1 索引策略

| 索引名称 | 字段 | 类型 | 用途 |
|---------|------|------|------|
| `PRIMARY KEY` | `id` | 唯一索引 | 主键查询 |
| `uk_finance_data` | `(company_no, type_no, keep_date)` | 唯一索引 | 去重约束 |
| `idx_finance_data_company` | `company_no` | B-Tree | 按公司查询 |
| `idx_finance_data_type` | `type_no` | B-Tree | 按类型查询 |
| `idx_finance_data_date` | `keep_date` | B-Tree | 按日期查询 |
| `idx_finance_data_query` | `(company_no, type_no, keep_date)` | 复合索引 | AI组合查询 |

### 6.2 查询优化示例

**❌ 未优化查询：**
```sql
-- 全表扫描
SELECT * FROM finance_data
WHERE company_name = '集团(合)' AND type_no = '01';
```

**✅ 优化查询：**
```sql
-- 使用索引（company_no而非company_name）
SELECT * FROM finance_data
WHERE company_no = 'lhjt' AND type_no = '01'
ORDER BY keep_date DESC;
```

### 6.3 连接池配置

```python
# 生产环境推荐配置
FINANCE_DB_POOL_SIZE=20          # 基础连接池大小
FINANCE_DB_MAX_OVERFLOW=40       # 最大溢出连接（峰值60个连接）
FINANCE_DB_POOL_TIMEOUT=30       # 连接超时30秒
FINANCE_DB_POOL_RECYCLE=3600     # 1小时回收连接（防止连接失效）
```

### 6.4 分区表（可选，未来优化）

**按年份分区（当数据量>100万条时考虑）：**

```sql
-- 创建父表（分区表）
CREATE TABLE finance_data_partitioned (
    LIKE finance_data INCLUDING ALL
) PARTITION BY RANGE (keep_date);

-- 创建分区
CREATE TABLE finance_data_2023 PARTITION OF finance_data_partitioned
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

CREATE TABLE finance_data_2024 PARTITION OF finance_data_partitioned
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE finance_data_2025 PARTITION OF finance_data_partitioned
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

**注意：** 当前数据量仅1016条，不需要分区，此方案仅供未来参考。

---

## 7. 备份与恢复策略

### 7.1 备份方案

#### 7.1.1 自动备份脚本

**文件：** `scripts/backup_finance_db.sh`

```bash
#!/bin/bash

BACKUP_DIR="/var/backups/medpol_finance"
DATE=$(date +%Y%m%d_%H%M%S)
FILENAME="medpol_finance_${DATE}.sql.gz"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 执行备份（使用pg_dump）
docker exec medpol-postgres-finance pg_dump \
    -U finance_user \
    -d medpol_finance \
    -F c \
    -Z 9 \
    > "${BACKUP_DIR}/${FILENAME}"

# 保留最近30天的备份
find $BACKUP_DIR -name "*.sql.gz" -mtime +30 -delete

echo "Backup completed: ${FILENAME}"
```

#### 7.1.2 Cron 定时备份

```bash
# 每天凌晨2点执行备份
0 2 * * * /path/to/scripts/backup_finance_db.sh >> /var/log/finance_backup.log 2>&1
```

### 7.2 恢复方案

```bash
# 方式1：使用docker exec恢复
docker exec -i medpol-postgres-finance psql \
    -U finance_user \
    -d medpol_finance \
    < backup_file.sql

# 方式2：使用pg_restore（针对custom format）
docker exec -i medpol-postgres-finance pg_restore \
    -U finance_user \
    -d medpol_finance \
    -c \
    < backup_file.dump
```

### 7.3 灾难恢复流程

1. **停止同步服务** - 防止数据进一步损坏
2. **创建新数据库** - `createdb medpol_finance_new`
3. **恢复备份** - `pg_restore`
4. **数据校验** - 检查记录数、最新日期
5. **切换数据库** - 更新DATABASE_URL
6. **重启服务** - 恢复正常运行

---

## 8. 数据库管理工具

### 8.1 推荐工具

- **pgAdmin** - 官方GUI管理工具
- **DBeaver** - 跨平台数据库IDE
- **psql** - 命令行工具

### 8.2 常用管理命令

```sql
-- 查看表大小
SELECT
    table_name,
    pg_size_pretty(pg_total_relation_size(quote_ident(table_name))) AS size
FROM information_schema.tables
WHERE table_schema = 'public'
ORDER BY pg_total_relation_size(quote_ident(table_name)) DESC;

-- 查看索引使用情况
SELECT
    indexrelname AS index_name,
    idx_scan AS index_scans,
    idx_tup_read AS tuples_read,
    idx_tup_fetch AS tuples_fetched
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;

-- 查看慢查询
SELECT
    query,
    calls,
    total_time,
    mean_time
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 10;

-- VACUUM优化
VACUUM ANALYZE finance_data;
VACUUM ANALYZE finance_sync_log;
```

---

## 9. 验收标准

### 9.1 功能验收

- [ ] 独立PostgreSQL实例成功创建（端口5433）
- [ ] 数据库表结构创建成功（finance_data + finance_sync_log）
- [ ] 唯一约束生效（插入重复数据报错）
- [ ] 索引创建成功（EXPLAIN ANALYZE验证）
- [ ] Session连接正常（finance_session_scope()可用）

### 9.2 性能验收

- [ ] 单条查询响应时间 < 10ms
- [ ] 1000条数据查询 < 50ms
- [ ] 按公司+类型+日期查询 < 5ms（索引生效）
- [ ] 并发10个查询无阻塞

### 9.3 数据验收

- [ ] 首次全量同步成功（1016条）
- [ ] 无重复数据（count(distinct ...) = count(*)）
- [ ] 数据完整性校验通过
- [ ] 备份恢复测试成功

---

## 10. 故障排查指南

### 10.1 常见问题

| 问题 | 原因 | 解决方案 |
|------|------|---------|
| 连接被拒绝 | 端口冲突/防火墙 | 检查端口5433、检查docker容器状态 |
| 唯一约束冲突 | 重复数据 | 检查去重逻辑、使用ON CONFLICT |
| 查询慢 | 缺少索引 | EXPLAIN ANALYZE、创建复合索引 |
| 数据库磁盘满 | 日志膨胀 | VACUUM FULL、清理日志 |
| Alembic迁移失败 | 模型不一致 | 检查FinanceBase.metadata、手动修复 |

### 10.2 诊断命令

```bash
# 检查容器状态
docker ps | grep finance

# 查看容器日志
docker logs medpol-postgres-finance

# 进入PostgreSQL容器
docker exec -it medpol-postgres-finance psql -U finance_user -d medpol_finance

# 测试连接
psql "postgresql://finance_user:finance_password@localhost:5433/medpol_finance"
```

---

## 11. 相关文档

- [财务数据接口文档](./01_财务数据接口文档.md)
- [财务数据同步方案](./03_财务数据同步方案.md)
- [AI对话集成方案v2](./04_AI对话集成方案_v2.md)
- [财务数据实施路线图](./05_财务数据实施路线图.md)

---

**文档维护:** AI助手 + 数据库团队
**审核状态:** 待审核
**下一步:** 执行数据库迁移并验证

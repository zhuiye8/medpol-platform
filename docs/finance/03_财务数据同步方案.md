# 财务数据同步方案

> **文档版本:** v1.0
> **更新日期:** 2025-11-15
> **同步策略:** 首次全量 + 月度增量
> **定时计划:** 每月1号凌晨4点
> **文档状态:** ✅ 方案定稿

---

## 1. 同步策略概述

### 1.1 设计理念

```
首次运行 → 全量同步历史数据（2023-11 至今，约1016条）
         ↓
后续运行 → 增量同步最新月份（每月仅50-80条）
         ↓
定时触发 → 每月1号凌晨4点自动执行
```

**核心优势：**
- ✅ **减少API调用** - 每月仅调用1次API，降低99%的流量
- ✅ **数据本地化** - AI查询直接走PostgreSQL，响应时间<100ms
- ✅ **历史数据完整** - 一次性同步所有历史数据
- ✅ **自动化运行** - 无需人工干预，每月自动更新

### 1.2 同步模式对比

| 模式 | 触发时机 | 数据范围 | 调用次数 | 适用场景 |
|------|---------|---------|---------|---------|
| **全量同步** | 首次部署 | 2023-11至今（全部历史） | 1次（无参数调用） | 初始化数据库 |
| **增量同步** | 每月1号 | 仅上月数据（约50-80条） | 1次（传keepDate参数） | 月度数据更新 |
| **手动同步** | API触发 | 指定月份或全量 | 按需 | 数据补录、修复 |

### 1.3 数据流转

```
┌─────────────────┐
│  外部财务API    │ http://ailianhuan.xyz:8333/financeDate/dataList
└────────┬────────┘
         │ POST请求
         ▼
┌─────────────────┐
│ FinanceAPIClient│ HTTP调用 + 错误重试
└────────┬────────┘
         │ 返回JSON数据
         ▼
┌─────────────────┐
│  数据验证 & 清洗 │ 字段校验、类型转换
└────────┬────────┘
         │ 清洗后的数据
         ▼
┌─────────────────┐
│   去重检测       │ 基于唯一键(company_no, type_no, keep_date)
└────────┬────────┘
         │ 新数据
         ▼
┌─────────────────┐
│  批量写入数据库  │ PostgreSQL事务
└────────┬────────┘
         │ 写入成功
         ▼
┌─────────────────┐
│  更新同步日志    │ finance_sync_log
└─────────────────┘
```

---

## 2. 同步服务架构

### 2.1 模块结构

```
finance_sync_service/
├── __init__.py              # 模块导出
├── sync_worker.py           # 同步主逻辑
├── finance_api_client.py    # API调用封装
├── models.py                # ORM模型（FinanceDataORM + FinanceSyncLogORM）
├── repository.py            # 数据访问层
└── utils.py                 # 工具函数（数据转换、校验）
```

### 2.2 核心类设计

#### 2.2.1 FinanceAPIClient（API客户端）

**职责：**
- 调用外部财务API
- HTTP错误处理
- 超时重试
- 响应解析

**接口：**
```python
class FinanceAPIClient:
    def get_all_data() -> List[Dict]
    def get_data_by_month(keep_date: str) -> List[Dict]
```

#### 2.2.2 FinanceSyncWorker（同步执行器）

**职责：**
- 执行全量/增量同步
- 数据去重
- 批量入库
- 日志记录

**接口：**
```python
class FinanceSyncWorker:
    def sync_full() -> FinanceSyncLogORM
    def sync_incremental(month: date) -> FinanceSyncLogORM
    def sync_manual(month: Optional[date] = None) -> FinanceSyncLogORM
```

#### 2.2.3 FinanceDataRepository（数据仓储）

**职责：**
- CRUD操作
- 去重检测
- 批量插入
- 数据查询

**接口：**
```python
class FinanceDataRepository:
    def bulk_upsert(records: List[FinanceDataORM]) -> int
    def exists(company_no: str, type_no: str, keep_date: date) -> bool
    def count_by_month(month: date) -> int
    def get_latest_month() -> Optional[date]
```

### 2.3 依赖关系

```
sync_worker.py
    ├── finance_api_client.py    (API调用)
    ├── repository.py             (数据库操作)
    ├── models.py                 (ORM模型)
    └── utils.py                  (数据转换)
```

---

## 3. 同步流程详解

### 3.1 全量同步流程

**使用场景：** 首次部署、数据重建

```python
def sync_full():
    """
    全量同步流程
    1. 调用API获取全部历史数据（无参数）
    2. 验证并清洗数据
    3. 批量插入数据库（ON CONFLICT DO NOTHING）
    4. 记录同步日志
    """
    log = FinanceSyncLogORM(
        id=str(uuid4()),
        sync_month=None,  # 全量同步无特定月份
        sync_mode='full',
        status='running',
        started_at=datetime.utcnow(),
        triggered_by='manual'
    )
    session.add(log)
    session.commit()

    try:
        # 1. 调用API
        start = time.time()
        raw_data = api_client.get_all_data()
        api_time = int((time.time() - start) * 1000)
        log.total_records = len(raw_data)
        log.api_response_time_ms = api_time

        # 2. 数据转换
        finance_records = [
            convert_to_orm(item) for item in raw_data
        ]

        # 3. 批量插入（去重）
        new_count = repository.bulk_upsert(finance_records)
        log.new_records = new_count
        log.duplicate_records = log.total_records - new_count

        # 4. 标记成功
        log.status = 'success'
        log.finished_at = datetime.utcnow()
        log.duration_ms = int((log.finished_at - log.started_at).total_seconds() * 1000)

    except Exception as e:
        log.status = 'failed'
        log.error_message = str(e)
        log.finished_at = datetime.utcnow()
        raise
    finally:
        session.commit()

    return log
```

**预计耗时：** 10-30秒（取决于网络和数据库性能）

### 3.2 增量同步流程

**使用场景：** 月度定时任务

```python
def sync_incremental(target_month: Optional[date] = None):
    """
    增量同步流程（默认同步上月数据）
    1. 确定目标月份（默认为上月1号）
    2. 调用API获取指定月份数据
    3. 去重并插入数据库
    4. 记录同步日志
    """
    # 默认同步上月数据
    if target_month is None:
        today = date.today()
        last_month = today.replace(day=1) - timedelta(days=1)
        target_month = last_month.replace(day=1)

    keep_date_str = target_month.strftime("%Y-%m-%d")

    log = FinanceSyncLogORM(
        id=str(uuid4()),
        sync_month=target_month,
        sync_mode='incremental',
        status='running',
        started_at=datetime.utcnow(),
        triggered_by='scheduler'
    )
    session.add(log)
    session.commit()

    try:
        # 1. 调用API（按月查询）
        start = time.time()
        raw_data = api_client.get_data_by_month(keep_date_str)
        api_time = int((time.time() - start) * 1000)
        log.total_records = len(raw_data)
        log.api_response_time_ms = api_time

        # 检查是否有数据
        if not raw_data:
            logger.warning(f"No data found for {keep_date_str}")
            log.status = 'success'
            log.finished_at = datetime.utcnow()
            session.commit()
            return log

        # 2. 数据转换
        finance_records = [
            convert_to_orm(item) for item in raw_data
        ]

        # 3. 批量插入
        new_count = repository.bulk_upsert(finance_records)
        log.new_records = new_count
        log.duplicate_records = log.total_records - new_count

        # 4. 标记成功
        log.status = 'success'
        log.finished_at = datetime.utcnow()
        log.duration_ms = int((log.finished_at - log.started_at).total_seconds() * 1000)

    except Exception as e:
        log.status = 'failed'
        log.error_message = str(e)
        log.finished_at = datetime.utcnow()
        raise
    finally:
        session.commit()

    return log
```

**预计耗时：** 5-10秒

### 3.3 数据转换逻辑

**文件：** `finance_sync_service/utils.py`

```python
from datetime import datetime, date
from decimal import Decimal
from uuid import uuid4
from typing import Dict, Optional

def convert_to_orm(raw_item: Dict) -> FinanceDataORM:
    """
    将API返回的JSON转换为ORM对象

    输入示例：
    {
        "id": "1",
        "companyNo": "lhjt",
        "keepDate": "2024-01-01",
        "currentAmt": 66455.17,
        ...
    }
    """
    return FinanceDataORM(
        id=raw_item.get("id") or str(uuid4()),
        company_no=raw_item["companyNo"],
        company_id=raw_item["companyId"],
        company_name=raw_item["companyName"],
        company_level=raw_item["level"],
        type_no=raw_item["typeNo"],
        keep_date=parse_date(raw_item["keepDate"]),
        current_amt=safe_decimal(raw_item.get("currentAmt")),
        last_year_amt=safe_decimal(raw_item.get("lastYearAmt")),
        last_year_total_amt=safe_decimal(raw_item.get("lastYearTotalAmt")),
        this_year_total_amt=safe_decimal(raw_item.get("thisYearTotalAmt")),
        add_amt=safe_decimal(raw_item.get("addAmt")),
        add_rate=safe_decimal(raw_item.get("addRate")),
        year_add_amt=safe_decimal(raw_item.get("yearAddAmt")),
        year_add_rate=safe_decimal(raw_item.get("yearAddRate")),
        remarks=raw_item.get("remarks"),
        synced_at=datetime.utcnow()
    )

def parse_date(date_str: str) -> date:
    """解析日期字符串：2024-01-01 → date(2024, 1, 1)"""
    return datetime.strptime(date_str, "%Y-%m-%d").date()

def safe_decimal(value: Optional[float]) -> Optional[Decimal]:
    """安全转换为Decimal，处理None和NaN"""
    if value is None or (isinstance(value, float) and value != value):  # NaN check
        return None
    return Decimal(str(value))
```

### 3.4 批量插入逻辑（去重）

**文件：** `finance_sync_service/repository.py`

```python
from sqlalchemy.dialects.postgresql import insert
from sqlalchemy.orm import Session
from typing import List

class FinanceDataRepository:
    def __init__(self, session: Session):
        self.session = session

    def bulk_upsert(self, records: List[FinanceDataORM]) -> int:
        """
        批量插入数据，遇到重复则跳过

        使用PostgreSQL的ON CONFLICT DO NOTHING语法
        返回实际插入的记录数
        """
        if not records:
            return 0

        # 方式1：使用SQLAlchemy的insert().on_conflict_do_nothing()
        stmt = insert(FinanceDataORM).values([
            {
                "id": r.id,
                "company_no": r.company_no,
                "company_id": r.company_id,
                "company_name": r.company_name,
                "company_level": r.company_level,
                "type_no": r.type_no,
                "keep_date": r.keep_date,
                "current_amt": r.current_amt,
                "last_year_amt": r.last_year_amt,
                "last_year_total_amt": r.last_year_total_amt,
                "this_year_total_amt": r.this_year_total_amt,
                "add_amt": r.add_amt,
                "add_rate": r.add_rate,
                "year_add_amt": r.year_add_amt,
                "year_add_rate": r.year_add_rate,
                "remarks": r.remarks,
                "synced_at": r.synced_at,
            }
            for r in records
        ]).on_conflict_do_nothing(
            index_elements=["company_no", "type_no", "keep_date"]
        )

        result = self.session.execute(stmt)
        self.session.commit()

        return result.rowcount  # 实际插入的记录数

    def get_latest_month(self) -> Optional[date]:
        """获取数据库中最新的月份"""
        result = self.session.query(
            func.max(FinanceDataORM.keep_date)
        ).scalar()
        return result

    def count_by_month(self, month: date) -> int:
        """统计指定月份的记录数"""
        return self.session.query(FinanceDataORM).filter(
            FinanceDataORM.keep_date == month
        ).count()
```

---

## 4. 调度配置

### 4.1 复用现有调度系统

**项目现有调度架构：** 基于 `CrawlerJobORM` 的自定义调度系统

**优势：**
- ✅ 无需引入Celery Beat
- ✅ 配置存储在数据库（可动态修改）
- ✅ 完整的执行历史记录
- ✅ 支持手动触发
- ✅ Web UI管理界面

### 4.2 创建调度任务

**方式1：通过API创建（推荐）**

```bash
curl -X POST "http://localhost:8000/v1/crawler-jobs" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "财务数据月度同步",
    "crawler_name": "finance_sync",
    "source_id": "finance_api",
    "job_type": "scheduled",
    "schedule_cron": "0 4 1 * *",
    "interval_minutes": null,
    "payload": {
      "sync_mode": "incremental"
    },
    "enabled": true
  }'
```

**方式2：通过数据库初始化脚本**

**文件：** `scripts/seed_finance_sync_job.py`

```python
#!/usr/bin/env python3
"""
初始化财务数据同步定时任务
"""
from datetime import datetime, timezone
from uuid import uuid4
from common.persistence.database import session_scope
from common.persistence.models import CrawlerJobORM, SourceORM
from scheduler_service.job_runner import calculate_next_run_time

def seed_finance_sync_job():
    """创建财务数据同步任务"""
    with session_scope() as session:
        # 1. 创建数据源（如果不存在）
        source = session.query(SourceORM).filter_by(name="finance_api").first()
        if not source:
            source = SourceORM(
                id=str(uuid4()),
                name="finance_api",
                label="财务数据API",
                base_url="http://ailianhuan.xyz:8333",
                category="external_api",
                is_active=True,
                meta={"description": "外部财务数据接口"}
            )
            session.add(source)
            session.flush()

        # 2. 创建调度任务
        job = session.query(CrawlerJobORM).filter_by(
            crawler_name="finance_sync"
        ).first()

        if job:
            print(f"财务同步任务已存在: {job.id}")
            return job

        job = CrawlerJobORM(
            id=str(uuid4()),
            name="财务数据月度同步",
            crawler_name="finance_sync",
            source_id=source.id,
            job_type="scheduled",
            schedule_cron="0 4 1 * *",  # 每月1号凌晨4点
            interval_minutes=None,
            payload={
                "sync_mode": "incremental",
                "auto_retry": True,
                "max_retries": 3
            },
            enabled=True,
            next_run_at=calculate_next_run_time(
                job_type="scheduled",
                schedule_cron="0 4 1 * *",
                interval_minutes=None,
                enabled=True
            )
        )
        session.add(job)
        session.commit()

        print(f"✅ 财务同步任务创建成功: {job.id}")
        print(f"   下次运行时间: {job.next_run_at}")
        return job

if __name__ == "__main__":
    seed_finance_sync_job()
```

**执行：**
```bash
python scripts/seed_finance_sync_job.py
```

### 4.3 Cron 表达式详解

```
0 4 1 * *
│ │ │ │ │
│ │ │ │ └─ 星期几 (0-7, 0和7都表示星期日)
│ │ │ └─── 月份 (1-12)
│ │ └───── 日期 (1-31)
│ └─────── 小时 (0-23)
└───────── 分钟 (0-59)
```

**示例：**
- `0 4 1 * *` - 每月1号凌晨4点
- `0 2 * * *` - 每天凌晨2点
- `0 */6 * * *` - 每6小时一次
- `30 3 1,15 * *` - 每月1号和15号的3:30

**修改同步时间：**
```bash
# 通过API更新
curl -X PATCH "http://localhost:8000/v1/crawler-jobs/{job_id}" \
  -H "Content-Type: application/json" \
  -d '{"schedule_cron": "0 2 1 * *"}'  # 改为凌晨2点
```

### 4.4 调度执行流程

```
┌─────────────────┐
│ run_scheduler.py│ 每60秒轮询一次
└────────┬────────┘
         │ 查询 next_run_at <= now() 的任务
         ▼
┌─────────────────┐
│ 检测到任务到期  │ CrawlerJobORM.crawler_name = 'finance_sync'
└────────┬────────┘
         │ 调用执行器
         ▼
┌─────────────────┐
│ finance_sync_worker.sync_incremental()
└────────┬────────┘
         │ 执行同步
         ▼
┌─────────────────┐
│ 更新任务状态    │ last_run_at, last_status, next_run_at
└─────────────────┘
```

**关键代码位置：** `scheduler_service/job_runner.py`

需要新增财务同步的执行逻辑：

```python
from finance_sync_service.sync_worker import FinanceSyncWorker

def execute_job_once(job: CrawlerJobORM, run: CrawlerJobRunORM, session: Session) -> int:
    """执行任务一次"""
    # ... 现有代码

    # 新增：财务同步任务
    if job.crawler_name == "finance_sync":
        from finance_sync_service.sync_worker import sync_incremental
        result = sync_incremental()
        return result.new_records  # 返回新增记录数

    # ... 其他爬虫逻辑
```

---

## 5. 首次全量同步脚本

**文件：** `scripts/finance_initial_sync.py`

```python
#!/usr/bin/env python3
"""
财务数据首次全量同步脚本

用途：初始化财务数据库，同步2023-11至今的全部历史数据

执行：python scripts/finance_initial_sync.py
"""
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

from finance_sync_service.sync_worker import FinanceSyncWorker
from common.persistence.finance_database import finance_session_scope

def main():
    """执行全量同步"""
    print("=" * 60)
    print("财务数据全量同步脚本")
    print("=" * 60)
    print()

    # 确认
    confirm = input("是否执行全量同步？这将同步2023-11至今的所有数据 (y/N): ")
    if confirm.lower() != 'y':
        print("❌ 已取消")
        return

    print()
    print("开始同步...")

    try:
        with finance_session_scope() as session:
            worker = FinanceSyncWorker(session)
            log = worker.sync_full()

            print()
            print("=" * 60)
            print("✅ 全量同步完成！")
            print("=" * 60)
            print(f"同步ID:       {log.id}")
            print(f"同步模式:     {log.sync_mode}")
            print(f"状态:         {log.status}")
            print(f"总记录数:     {log.total_records}")
            print(f"新增记录:     {log.new_records}")
            print(f"重复记录:     {log.duplicate_records}")
            print(f"耗时:         {log.duration_ms / 1000:.2f} 秒")
            print(f"API响应时间:  {log.api_response_time_ms / 1000:.2f} 秒")
            print()

            if log.status == 'failed':
                print(f"❌ 错误信息: {log.error_message}")
                sys.exit(1)

    except Exception as e:
        print(f"❌ 同步失败: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
```

**执行示例：**
```bash
$ python scripts/finance_initial_sync.py

============================================================
财务数据全量同步脚本
============================================================

是否执行全量同步？这将同步2023-11至今的所有数据 (y/N): y

开始同步...

============================================================
✅ 全量同步完成！
============================================================
同步ID:       d1234567-89ab-cdef-0123-456789abcdef
同步模式:     full
状态:         success
总记录数:     1016
新增记录:     1016
重复记录:     0
耗时:         15.32 秒
API响应时间:  1.85 秒
```

---

## 6. 错误处理与重试

### 6.1 错误分类

| 错误类型 | 示例 | 处理方式 |
|---------|------|---------|
| **网络错误** | ConnectionTimeout, ConnectionRefused | 重试3次，指数退避 |
| **API错误** | HTTP 500, 响应格式错误 | 重试1次，记录日志 |
| **数据错误** | 字段缺失、类型错误 | 跳过该记录，记录warn日志 |
| **数据库错误** | 唯一约束冲突 | 正常（去重生效），继续 |
| **未知错误** | 其他异常 | 回滚事务，标记失败 |

### 6.2 重试机制

**文件：** `finance_sync_service/finance_api_client.py`

```python
import requests
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

class FinanceAPIClient:
    BASE_URL = "http://ailianhuan.xyz:8333"
    TIMEOUT = 30

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type((requests.Timeout, requests.ConnectionError))
    )
    def get_all_data(self) -> List[Dict]:
        """
        获取全量数据（带重试）

        重试策略：
        - 最多重试3次
        - 指数退避：2秒、4秒、8秒
        - 仅对网络错误重试
        """
        url = f"{self.BASE_URL}/financeDate/dataList"
        response = requests.post(url, timeout=self.TIMEOUT)
        response.raise_for_status()

        data = response.json()
        if data.get("code") != "0000":
            raise APIError(f"API返回错误: {data.get('msg')}")

        return data.get("data", [])

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type((requests.Timeout, requests.ConnectionError))
    )
    def get_data_by_month(self, keep_date: str) -> List[Dict]:
        """按月查询数据（带重试）"""
        url = f"{self.BASE_URL}/financeDate/dataList"
        params = {"keepDate": keep_date}
        response = requests.post(url, params=params, timeout=self.TIMEOUT)
        response.raise_for_status()

        data = response.json()
        if data.get("code") != "0000":
            raise APIError(f"API返回错误: {data.get('msg')}")

        return data.get("data", [])

class APIError(Exception):
    """API调用错误"""
    pass
```

**依赖：**
```bash
pip install tenacity  # 重试库
```

### 6.3 数据校验

```python
from typing import Dict, List
import logging

logger = logging.getLogger(__name__)

def validate_finance_record(raw_item: Dict) -> bool:
    """
    校验单条财务记录

    必填字段：companyNo, companyId, typeNo, keepDate
    可选字段：金额字段（允许为None）
    """
    required_fields = ["companyNo", "companyId", "companyName", "typeNo", "keepDate", "level"]

    for field in required_fields:
        if field not in raw_item or raw_item[field] is None:
            logger.warning(f"记录缺少必填字段 {field}: {raw_item}")
            return False

    # 校验日期格式
    try:
        datetime.strptime(raw_item["keepDate"], "%Y-%m-%d")
    except ValueError:
        logger.warning(f"日期格式错误: {raw_item['keepDate']}")
        return False

    # 校验财务类型
    if raw_item["typeNo"] not in ["01", "02", "03", "04", "06", "07", "08"]:
        logger.warning(f"未知财务类型: {raw_item['typeNo']}")
        return False

    return True

def filter_valid_records(raw_data: List[Dict]) -> List[Dict]:
    """过滤有效记录"""
    valid = []
    invalid_count = 0

    for item in raw_data:
        if validate_finance_record(item):
            valid.append(item)
        else:
            invalid_count += 1

    if invalid_count > 0:
        logger.warning(f"过滤了 {invalid_count} 条无效记录")

    return valid
```

---

## 7. 监控与日志

### 7.1 同步日志查询

**查询最近10次同步记录：**
```sql
SELECT
    sync_month,
    sync_mode,
    status,
    total_records,
    new_records,
    duration_ms / 1000 AS duration_sec,
    started_at
FROM finance_sync_log
ORDER BY started_at DESC
LIMIT 10;
```

**查询失败记录：**
```sql
SELECT
    sync_month,
    status,
    error_message,
    started_at
FROM finance_sync_log
WHERE status = 'failed'
ORDER BY started_at DESC;
```

### 7.2 API接口查询

**文件：** `api_gateway/routers/finance_sync.py`

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from api_gateway.deps import get_db
from finance_sync_service.models import FinanceSyncLogORM

router = APIRouter(prefix="/v1/finance-sync", tags=["finance-sync"])

@router.get("/logs")
def get_sync_logs(
    limit: int = 10,
    session: Session = Depends(get_db)
):
    """查询同步日志"""
    logs = session.query(FinanceSyncLogORM).order_by(
        FinanceSyncLogORM.started_at.desc()
    ).limit(limit).all()

    return {
        "code": 0,
        "msg": "success",
        "data": [
            {
                "id": log.id,
                "sync_month": log.sync_month.isoformat() if log.sync_month else None,
                "sync_mode": log.sync_mode,
                "status": log.status,
                "total_records": log.total_records,
                "new_records": log.new_records,
                "duration_ms": log.duration_ms,
                "started_at": log.started_at.isoformat(),
                "error_message": log.error_message
            }
            for log in logs
        ]
    }

@router.post("/trigger")
def trigger_sync_manual(
    month: Optional[str] = None,  # 格式：2024-03
    session: Session = Depends(get_db)
):
    """手动触发同步"""
    from finance_sync_service.sync_worker import sync_manual

    if month:
        target_date = datetime.strptime(f"{month}-01", "%Y-%m-%d").date()
    else:
        target_date = None

    log = sync_manual(target_date)

    return {
        "code": 0,
        "msg": "同步完成",
        "data": {
            "sync_id": log.id,
            "status": log.status,
            "new_records": log.new_records
        }
    }
```

### 7.3 告警通知（可选）

**Slack通知示例：**
```python
import requests

def send_slack_alert(log: FinanceSyncLogORM):
    """发送Slack告警"""
    if log.status == 'failed':
        webhook_url = os.getenv("SLACK_WEBHOOK_URL")
        if not webhook_url:
            return

        message = {
            "text": f"❌ 财务数据同步失败！",
            "blocks": [
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*财务数据同步失败*\n月份: {log.sync_month}\n错误: {log.error_message}"
                    }
                }
            ]
        }
        requests.post(webhook_url, json=message)
```

---

## 8. 数据一致性校验

### 8.1 校验脚本

**文件：** `scripts/verify_finance_data.py`

```python
#!/usr/bin/env python3
"""
数据一致性校验脚本

检查：
1. 数据完整性（是否有缺失月份）
2. 记录数合理性（每月20-80条）
3. 数据重复（不应存在）
4. 金额合理性（不应为负数，除净利润外）
"""
from common.persistence.finance_database import finance_session_scope
from finance_sync_service.models import FinanceDataORM
from sqlalchemy import func

def verify_data_integrity():
    """数据完整性校验"""
    with finance_session_scope() as session:
        # 1. 统计每月记录数
        monthly_counts = session.query(
            FinanceDataORM.keep_date,
            func.count(FinanceDataORM.id).label('count')
        ).group_by(FinanceDataORM.keep_date).all()

        print("月度记录数统计：")
        for month, count in monthly_counts:
            status = "✅" if 20 <= count <= 100 else "⚠️"
            print(f"{status} {month}: {count} 条")

        # 2. 检查重复记录
        duplicates = session.query(
            FinanceDataORM.company_no,
            FinanceDataORM.type_no,
            FinanceDataORM.keep_date,
            func.count(FinanceDataORM.id).label('count')
        ).group_by(
            FinanceDataORM.company_no,
            FinanceDataORM.type_no,
            FinanceDataORM.keep_date
        ).having(func.count(FinanceDataORM.id) > 1).all()

        if duplicates:
            print(f"\n❌ 发现 {len(duplicates)} 组重复数据！")
            for dup in duplicates:
                print(f"   {dup}")
        else:
            print("\n✅ 无重复数据")

        # 3. 检查总记录数
        total = session.query(func.count(FinanceDataORM.id)).scalar()
        print(f"\n总记录数: {total}")

if __name__ == "__main__":
    verify_data_integrity()
```

---

## 9. 常见问题（FAQ）

### Q1: 首次同步需要多长时间？

**A:** 约10-30秒，取决于网络速度和数据库性能。1016条数据，API响应约2秒，数据库插入约5-10秒。

### Q2: 如果同步失败怎么办？

**A:** 同步失败会记录在 `finance_sync_log` 表中，可通过以下方式重试：
1. 手动执行脚本：`python scripts/finance_initial_sync.py`（全量）
2. 调用API：`POST /v1/finance-sync/trigger?month=2024-03`（指定月份）
3. 等待下次定时任务自动重试

### Q3: 如何修改同步时间？

**A:** 通过API更新CrawlerJobORM的schedule_cron字段：
```bash
curl -X PATCH "/v1/crawler-jobs/{job_id}" \
  -d '{"schedule_cron": "0 2 1 * *"}'  # 改为凌晨2点
```

### Q4: 如何补录历史数据？

**A:** 手动触发指定月份的同步：
```bash
# Python脚本
python -c "from finance_sync_service.sync_worker import sync_incremental; sync_incremental('2024-05-01')"

# 或通过API
curl -X POST "/v1/finance-sync/trigger?month=2024-05"
```

### Q5: 数据重复怎么办？

**A:** 数据库有唯一约束，重复数据会被自动跳过。如需清理：
```sql
-- 查找重复
SELECT company_no, type_no, keep_date, COUNT(*)
FROM finance_data
GROUP BY company_no, type_no, keep_date
HAVING COUNT(*) > 1;

-- 删除重复（保留ID最小的）
DELETE FROM finance_data a
USING finance_data b
WHERE a.id > b.id
  AND a.company_no = b.company_no
  AND a.type_no = b.type_no
  AND a.keep_date = b.keep_date;
```

---

## 10. 相关文档

- [财务数据接口文档](./01_财务数据接口文档.md)
- [财务数据库设计方案](./02_财务数据库设计方案.md)
- [AI对话集成方案v2](./04_AI对话集成方案_v2.md)
- [财务数据实施路线图](./05_财务数据实施路线图.md)

---

**文档维护:** AI助手 + 开发团队
**审核状态:** 待审核
**下一步:** 编写同步服务代码并执行首次同步
